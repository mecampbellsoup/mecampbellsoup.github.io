<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: json | Thoughts & Technical Writings.]]></title>
  <link href="http://mattcampbell.nyc/blog/categories/json/atom.xml" rel="self"/>
  <link href="http://mattcampbell.nyc/"/>
  <updated>2017-03-04T15:12:09-05:00</updated>
  <id>http://mattcampbell.nyc/</id>
  <author>
    <name><![CDATA[Matt Campbell]]></name>
    <email><![CDATA[mecampbell25@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How-To: Manual JSON-endpoint Testing Made Easy]]></title>
    <link href="http://mattcampbell.nyc/2014/05/27/how-to-easy-manual-testing-a-json-http-endpoint/"/>
    <updated>2014-05-27T10:25:00-04:00</updated>
    <id>http://mattcampbell.nyc/2014/05/27/how-to-easy-manual-testing-a-json-http-endpoint</id>
    <content type="html"><![CDATA[<p>Let&rsquo;s say your shiny new web application relies upon a 3rd party REST API like, say, <a href="http://www.twilio.com/docs/api/rest/response#response-formats-json">Twilio</a>. Those guys and gals do a really nice job adhering to <a href="http://stackoverflow.com/questions/671118/what-exactly-is-restful-programming">REST principles</a> when it comes to their API&rsquo;s design. But as a software developer trying to communicate with their API, what are the practical implications of having a RESTful API on the other end of the wire?</p>

<h2>Quick REST refreshment&hellip;</h2>

<p>REST is a fairly large set of principles, but for this example we&rsquo;ll focus on one aspect: The &lsquo;R&rsquo; in REST stands for &lsquo;<strong>RE</strong>presentational (<strong>S</strong>tate <strong>T</strong>ransfer)&rsquo;.</p>

<p>All URLs referenced in Twilio&rsquo;s documentation have the following base:</p>

<pre><code class="bash">https://api.twilio.com/2010-04-01
</code></pre>

<p>Now, we want to dig a little deeper into the &ldquo;subresources&rdquo; that Twilio exposes for our account. Take a look at the following URL endpoint (truncated for brevity):</p>

<pre><code class="bash">https://api.twilio.com/2010-04-01/Accounts/AC228b9.../SMS/Messages/SM1f0e8ae6ade43cb3c0ce4525424e404f.json
</code></pre>

<p>Because the Twilio API is RESTful, we can observe the URI itself and garner quite a bit of information about the resource we&rsquo;re requesting. In this case, it&rsquo;s clearly a particular SMS instance generated by (presumably our) account ID <code>AC228b9</code>. The &ldquo;representation&rdquo; of this SMS resource is extremely intuitive, and we have REST to thank for it!</p>

<h2>&lsquo;R&rsquo; is for &lsquo;Representational&rsquo;</h2>

<p>But I want to focus now on something I haven&rsquo;t yet mentioned regarding the URL above - specifically, the <code>.json</code> suffix. RESTful APIs, like Twilio&rsquo;s, typically allow a client (e.g. web bowser, <a href="http://curl.haxx.se/download.html"><code>curl</code></a>, etc.) to request a particular representation of the desired resource. <a href="http://www.json.org/">JSON</a> has become an extremely popular such representation because, &ldquo;It is easy for humans to read and write&hellip; It is easy for machines to parse and generate.&rdquo; Given its ease-of-use and ubiquity across the interwebs, you will inevitably run into JSON endpoints as a web developer. There are many tools for working with the JSON response, but I think I may have come across one of the best strategies particularly for <a href="http://blog.jayfields.com/2014/01/repl-driven-development.html">REPL-driven development</a> and prototyping enthusiasts&hellip;</p>

<h2>Step 1: Get jq</h2>

<p><a href="https://github.com/stedolan/jq"><code>jq</code></a> is a command-line utility for parsing JSON input from STDIN (or from files, etc.; it&rsquo;s a BASH utility after all). Install it with:</p>

<p><code>brew install jq</code></p>

<p>Now, play around with it - try something like this (where <code>jq .</code> kicks off a <code>jq</code> process which waits for your input from STDIN):</p>

<pre><code class="bash">⇒  jq .
{"hello":"world"}
{
  "hello": "world"
}
</code></pre>

<h2>Step 2: GET (via curl) your JSON endpoint</h2>

<p>There is a great resource for working with JSON called <a href="http://www.jsontest.com/">JSON Test</a>. We can easily combine one of the JSON Test endpoints with <code>curl</code> to explore the (hypothetical) JSON representation of a resource like so:</p>

<pre><code class="bash">⇒  curl -s http://headers.jsontest.com
{
   "Host": "headers.jsontest.com",
   "User-Agent": "curl/7.30.0",
   "Accept": "*/*"
}
</code></pre>

<h2>Step 3: Combine steps 1 and 2 - it&rsquo;s that easy!</h2>

<p>Now that we have <code>jq</code> and <code>curl</code> down, we simply put them together by piping <code>curl</code>&rsquo;s STDOUT into the <code>jq</code> program like so:</p>

<pre><code class="bash">⇒  curl -s http://headers.jsontest.com | jq .
{
  "Accept": "*/*",
  "User-Agent": "curl/7.30.0",
  "Host": "headers.jsontest.com"
}
</code></pre>

<p>It might not look like you get much advantage by using <code>jq</code> over the standard <code>curl</code> formatted output - but <code>jq</code> really shines when you want to be able to sift through a very large JSON hash. Let&rsquo;s say you&rsquo;re reading from a <code>fake.json</code> file which contains hundreds of lines of JSON (you can take a quick look at the file <a href="https://gist.github.com/mecampbellsoup/c749e5f1b7769f57f457">in this gist</a>). That bad boy has 310 lines of JSON to be exact - <a href="https://www.youtube.com/watch?v=8cT_Ulmcrys&amp;feature=kp">ain&rsquo;t nobody got time fo&#8217; dat</a>! We can read the file and pipe the output into our trusty little friend <code>jq</code>; and then we can quickly identify, say, the first person&rsquo;s favorite fruit as follows:</p>

<pre><code class="bash">⇒  jq ".[0].favoriteFruit" &lt; fake.json
"strawberry"
</code></pre>

<p>(Note: I&rsquo;m using <code>"</code> above because <code>zsh</code> passes arguments to programs a little differently than <code>bash</code>. If using <code>bash</code>, you should be able to do simply: <code>jq .[0].favoriteFruit</code> without the quotes.)</p>

<p>By doing <code>[0]</code> I obtain the first element of the JSON array (which contains information relating to our first person); and <code>jq</code> allows me to pluck the value at a given key - in this case, the <code>favoriteFruit</code> key.</p>

<h2>Conclusion</h2>

<p>By combining <code>curl</code> with <code>jq</code>, you should never again have to struggle with manually quick-checking any server-generated JSON response that comes your way. Let me know if you found this helpful in the comments below!</p>
]]></content>
  </entry>
  
</feed>
